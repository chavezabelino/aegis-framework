#!/usr/bin/env node

/**
 * @aegisFrameworkVersion 2.0.0-alpha-dev
 * @intent Validate team configuration against constitutional requirements
 * @context Ensure team configurations maintain constitutional compliance
 */

import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import { 
  AegisFrameworkConfigSchema, 
  validateConstitutionalCompliance,
  type AegisFrameworkConfig 
} from '../framework/contracts/team-configuration.schema.js';

interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
  suggestions: string[];
}

class TeamConfigurationValidator {
  private workspaceRoot: string;
  private configPath: string;

  constructor(workspaceRoot: string = process.cwd()) {
    this.workspaceRoot = workspaceRoot;
    this.configPath = path.join(workspaceRoot, '.framework', 'team-config.yaml');
  }

  /**
   * Validate team configuration file
   */
  async validate(): Promise<ValidationResult> {
    const result: ValidationResult = {
      valid: true,
      errors: [],
      warnings: [],
      suggestions: []
    };

    // Check if configuration file exists
    if (!fs.existsSync(this.configPath)) {
      result.valid = false;
      result.errors.push('Team configuration file not found');
      result.suggestions.push('Run: node cli/team-config.ts setup');
      return result;
    }

    let config: AegisFrameworkConfig;

    try {
      // Load and parse configuration
      const content = fs.readFileSync(this.configPath, 'utf8');
      const data = yaml.load(content);
      config = AegisFrameworkConfigSchema.parse(data);
    } catch (error) {
      result.valid = false;
      result.errors.push(`Configuration parsing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return result;
    }

    // Validate constitutional compliance
    const compliance = validateConstitutionalCompliance(config);
    result.errors.push(...compliance.violations);
    result.warnings.push(...compliance.warnings);

    if (compliance.violations.length > 0) {
      result.valid = false;
    }

    // Additional validations
    this.validateOverrideExpiry(config, result);
    this.validateProfileConsistency(config, result);
    this.validateFeatureCoherence(config, result);
    this.validateTeamInfo(config, result);

    return result;
  }

  /**
   * Validate override expiry dates
   */
  private validateOverrideExpiry(config: AegisFrameworkConfig, result: ValidationResult): void {
    if (!config.overrides?.overrideExpiry) {
      return;
    }

    const expiry = new Date(config.overrides.overrideExpiry);
    const now = new Date();
    const daysRemaining = Math.ceil((expiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

    if (expiry < now) {
      result.errors.push('Override has expired and must be renewed');
      result.suggestions.push('Run: node cli/team-config.ts setup');
    } else if (daysRemaining <= 30) {
      result.warnings.push(`Override expires in ${daysRemaining} days`);
      result.suggestions.push('Consider planning override renewal');
    } else if (daysRemaining <= 7) {
      result.errors.push(`Override expires in ${daysRemaining} days - immediate renewal required`);
    }
  }

  /**
   * Validate profile consistency
   */
  private validateProfileConsistency(config: AegisFrameworkConfig, result: ValidationResult): void {
    const profile = config.team.profile;

    // Check if configuration matches declared profile
    if (profile === 'strict') {
      if (!config.required.evolutionStoryDetection.enabled) {
        result.warnings.push('Strict profile should have evolution story detection enabled');
      }
      if (config.required.constitutionalEnforcement.mode !== 'strict') {
        result.warnings.push('Strict profile should use strict constitutional enforcement mode');
      }
    }

    if (profile === 'minimal') {
      if (!config.overrides?.constitutionalAcknowledgment) {
        result.errors.push('Minimal profile requires constitutional acknowledgment');
      }
    }

    if (profile === 'balanced') {
      if (!config.required.evolutionStoryDetection.enabled) {
        result.warnings.push('Balanced profile typically has evolution story detection enabled');
      }
    }
  }

  /**
   * Validate feature configuration coherence
   */
  private validateFeatureCoherence(config: AegisFrameworkConfig, result: ValidationResult): void {
    // Check for contradictory settings
    if (!config.required.precommitHooks.enabled && config.required.precommitHooks.evolutionDetection) {
      result.warnings.push('Evolution detection in pre-commit hooks enabled but hooks are disabled');
    }

    if (!config.required.evolutionStoryDetection.enabled && config.optional.autoGeneratedEvolutionStories.enabled) {
      result.warnings.push('Auto-generated evolution stories enabled but detection is disabled');
    }

    if (config.required.constitutionalEnforcement.mode === 'advisory' && config.required.constitutionalEnforcement.blocking) {
      result.warnings.push('Constitutional enforcement set to advisory mode but blocking is enabled');
    }

    // Check for recommended combinations
    if (config.optional.driftMonitoringDashboard.enabled && !config.optional.realtimePatternDetection.enabled) {
      result.suggestions.push('Consider enabling real-time pattern detection with drift monitoring dashboard');
    }
  }

  /**
   * Validate team information
   */
  private validateTeamInfo(config: AegisFrameworkConfig, result: ValidationResult): void {
    if (!config.team.name || config.team.name.length < 2) {
      result.warnings.push('Team name should be more descriptive');
    }

    if (config.overrides?.approvedBy) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(config.overrides.approvedBy)) {
        result.errors.push('Override approved by email is invalid');
      }
    }

    if (config.overrides?.reason && config.overrides.reason.length < 10) {
      result.warnings.push('Override reason should be more detailed');
    }
  }

  /**
   * Generate configuration health report
   */
  async generateHealthReport(): Promise<void> {
    const result = await this.validate();

    console.log('🔍 Team Configuration Health Report\n');
    console.log(`📄 Configuration: ${this.configPath}`);
    console.log(`📅 Generated: ${new Date().toISOString()}\n`);

    // Overall status
    if (result.valid) {
      console.log('✅ Overall Status: VALID');
    } else {
      console.log('❌ Overall Status: INVALID');
    }

    // Errors
    if (result.errors.length > 0) {
      console.log('\n❌ Errors:');
      result.errors.forEach(error => console.log(`   - ${error}`));
    }

    // Warnings
    if (result.warnings.length > 0) {
      console.log('\n⚠️ Warnings:');
      result.warnings.forEach(warning => console.log(`   - ${warning}`));
    }

    // Suggestions
    if (result.suggestions.length > 0) {
      console.log('\n💡 Suggestions:');
      result.suggestions.forEach(suggestion => console.log(`   - ${suggestion}`));
    }

    // Configuration summary
    if (fs.existsSync(this.configPath)) {
      console.log('\n📊 Configuration Summary:');
      try {
        const content = fs.readFileSync(this.configPath, 'utf8');
        const config = AegisFrameworkConfigSchema.parse(yaml.load(content));
        
        console.log(`   Team: ${config.team.name}`);
        console.log(`   Profile: ${config.team.profile}`);
        console.log(`   Evolution Detection: ${config.required.evolutionStoryDetection.enabled ? 'Enabled' : 'Disabled'}`);
        console.log(`   Constitutional Mode: ${config.required.constitutionalEnforcement.mode}`);
        console.log(`   Pre-commit Hooks: ${config.required.precommitHooks.enabled ? 'Enabled' : 'Disabled'}`);
        
        if (config.overrides) {
          console.log(`   Override Expiry: ${config.overrides.overrideExpiry}`);
        }
      } catch (error) {
        console.log('   Error reading configuration details');
      }
    }

    console.log('');
  }

  /**
   * Check if configuration needs updates
   */
  async checkForUpdates(): Promise<void> {
    if (!fs.existsSync(this.configPath)) {
      console.log('No configuration found to check for updates.');
      return;
    }

    try {
      const content = fs.readFileSync(this.configPath, 'utf8');
      const config = AegisFrameworkConfigSchema.parse(yaml.load(content));
      
      console.log('🔄 Configuration Update Check\n');
      
      let updateNeeded = false;

      // Check for upcoming override expiry
      if (config.overrides?.overrideExpiry) {
        const expiry = new Date(config.overrides.overrideExpiry);
        const now = new Date();
        const daysRemaining = Math.ceil((expiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        
        if (daysRemaining <= 30) {
          console.log(`⏰ Override expires in ${daysRemaining} days`);
          console.log('   Consider scheduling renewal discussion');
          updateNeeded = true;
        }
      }

      // Check for new framework features (this would be expanded with actual feature detection)
      const frameworkVersion = '2.0.0-alpha-dev';
      console.log(`📦 Framework Version: ${frameworkVersion}`);
      
      // Check for configuration schema updates
      console.log('📋 Configuration Schema: Up to date');

      if (!updateNeeded) {
        console.log('✅ Configuration is current - no updates needed');
      }

    } catch (error) {
      console.error('Error checking for updates:', error);
    }
  }
}

// CLI interface
async function main() {
  const args = process.argv.slice(2);
  const command = args[0] || 'validate';

  const validator = new TeamConfigurationValidator();

  try {
    switch (command) {
      case 'validate':
        await validator.generateHealthReport();
        break;
      case 'check-updates':
        await validator.checkForUpdates();
        break;
      case 'quick':
        const result = await validator.validate();
        if (result.valid) {
          console.log('✅ Configuration valid');
          process.exit(0);
        } else {
          console.log('❌ Configuration invalid');
          result.errors.forEach(error => console.log(`   - ${error}`));
          process.exit(1);
        }
        break;
      default:
        console.log('Usage: node validate-team-config.ts [validate|check-updates|quick]');
        console.log('  validate      - Generate detailed health report');
        console.log('  check-updates - Check for configuration updates needed');
        console.log('  quick         - Quick validation (exit code based)');
    }
  } catch (error) {
    console.error('Error:', error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

// Run CLI if called directly
if (process.argv[1] && process.argv[1].endsWith('validate-team-config.ts')) {
  main();
}

export { TeamConfigurationValidator };
