#!/usr/bin/env node

/**
 * @aegisFrameworkVersion: 2.5.0
 * @intent: CLI tool for generating versioned agent instructions
 * @context: Automatically creates agent-specific instructions based on current framework state
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

interface FrameworkVersion {
  version: string;
  coreSpec: string;
  features: string[];
  capabilities: string[];
}

interface AgentInstructionTemplate {
  agent: string;
  capabilities: string[];
  specializations: string[];
  coordination: boolean;
}

class VersionedInstructionGenerator {
  private frameworkRoot: string;
  private versionsDir: string;
  private currentVersion: string;

  constructor() {
    this.frameworkRoot = path.resolve(__dirname, '..');
    this.versionsDir = path.join(this.frameworkRoot, 'framework', 'versions');
    this.currentVersion = this.getCurrentVersion();
  }

  private getCurrentVersion(): string {
    const versionPath = path.join(this.frameworkRoot, 'VERSION');
    return fs.readFileSync(versionPath, 'utf8').trim();
  }

  private getFrameworkFeatures(): string[] {
    const features: string[] = [];

    // Check for core alpha features
    if (fs.existsSync(path.join(this.frameworkRoot, 'framework', 'framework-core-v2.5.0.md'))) {
      features.push('blueprint-driven-development', 'constitutional-governance', 'semantic-versioning');
    }

    // Check for beta features (multi-agent)
    if (fs.existsSync(path.join(this.versionsDir, 'framework-core-v2.5.0)) {
      features.push('multi-agent-orchestration', 'mcp-metadata', 'drift-logging', 'adapter-interface');
    }

    // Check for apprenticeship features
    if (fs.existsSync(path.join(this.frameworkRoot, 'cli', 'apprenticeship-cli.ts'))) {
      features.push('apprenticeship-scaffolds', 'mentor-system', 'learning-integration');
    }

    // Check for observability features
    if (fs.existsSync(path.join(this.frameworkRoot, 'framework', 'observability'))) {
      features.push('advanced-observability', 'event-emission', 'telemetry');
    }

    return features;
  }

  private getAgentCapabilities(): AgentInstructionTemplate[] {
    const manifestPath = path.join(this.frameworkRoot, 'framework', 'agent-manifest.json');

    if (!fs.existsSync(manifestPath)) {
      return this.getDefaultAgentTemplates();
    }

    try {
      const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
      return Object.values(manifest.agents || {}).map((agent: any) => ({
        agent: agent.agentId,
        capabilities: agent.capabilities?.languages || [],
        specializations: agent.capabilities?.specializations || [],
        coordination: agent.coordinationSupport?.handoffs || false,
      }));
    } catch (error) {
      console.warn('Failed to parse agent manifest, using defaults');
      return this.getDefaultAgentTemplates();
    }
  }

  private getDefaultAgentTemplates(): AgentInstructionTemplate[] {
    return [
      {
        agent: 'github-copilot',
        capabilities: ['typescript', 'python', 'go', 'javascript'],
        specializations: ['full-stack', 'documentation', 'testing'],
        coordination: true,
      },
      {
        agent: 'claude-3-5-sonnet',
        capabilities: ['typescript', 'python', 'rust'],
        specializations: ['architecture', 'analysis', 'planning'],
        coordination: true,
      },
      {
        agent: 'cursor',
        capabilities: ['typescript', 'javascript', 'css'],
        specializations: ['frontend', 'ui-components', 'styling'],
        coordination: true,
      },
    ];
  }

  private generateInstructionContent(agent: AgentInstructionTemplate): string {
    const features = this.getFrameworkFeatures();
    const constitutionalSection = this.generateConstitutionalSection();
    const frameworkContextSection = this.generateFrameworkContextSection(features);
    const agentSpecificSection = this.generateAgentSpecificSection(agent);
    const blueprintSection = this.generateBlueprintSection();
    const observabilitySection = this.generateObservabilitySection(features);
    const cliSection = this.generateCLISection();
    const validationSection = this.generateValidationSection();
    const referenceSection = this.generateReferenceSection();

    return `<!--
@aegisFrameworkVersion: ${this.currentVersion}
@intent: Versioned ${agent.agent} agent instructions for current framework state
@context: ${features.join(', ')}
@target: ${agent.agent}
@generatedFrom: Auto-generated by generate-agent-instructions.ts
-->

# ü§ñ ${this.formatAgentName(agent.agent)} Instructions for Aegis Framework v${this.currentVersion}

> **Agent-specific guidance for ${this.formatAgentName(agent.agent)} working within the Aegis Framework ecosystem.**

${constitutionalSection}

${frameworkContextSection}

${agentSpecificSection}

${blueprintSection}

${observabilitySection}

${cliSection}

${validationSection}

${referenceSection}

---

**Version**: ${this.currentVersion}  
**Last Updated**: ${new Date().toISOString().split('T')[0]}  
**Target Agent**: ${this.formatAgentName(agent.agent)}  
**Framework Authority**: Aegis Framework Constitution`;
  }

  private formatAgentName(agentId: string): string {
    return agentId
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  private generateConstitutionalSection(): string {
    return `## üèõÔ∏è Constitutional Compliance

**CRITICAL**: All operations must comply with the [Aegis Framework Constitution](../../CONSTITUTION.md). This includes:

- **Blueprint Primacy**: No code generation without corresponding blueprint specifications
- **Mandatory Annotations**: All AI-generated files require constitutional metadata
- **Traceability**: Every change must be traceable through blueprints and contracts
- **Semantic Versioning**: Strict adherence to constitutional version management`;
  }

  private generateFrameworkContextSection(features: string[]): string {
    const capabilityMap: { [key: string]: string } = {
      'blueprint-driven-development': '**Core**: Blueprint-driven development with v2.5.0 specification',
      'multi-agent-orchestration': '**Multi-Agent**: v2.5.0 orchestration with agent coordination and handoffs',
      'apprenticeship-scaffolds': '**Apprenticeship**: v2.5.0 scaffolding system with mentor guidance',
      'advanced-observability': '**Observability**: MCP metadata emission, drift logging, run logs',
      'constitutional-governance': '**Governance**: Constitutional framework with democratic evolution',
    };

    const capabilities = features.map(f => capabilityMap[f]).filter(Boolean);

    return `## üéØ Framework Context (v${this.currentVersion})

### Current Capabilities
${capabilities.map(cap => `- ${cap}`).join('\n')}

### Execution Modes
- **lean**: Minimal implementation focusing on core requirements
- **strict**: Full compliance with all blueprint contracts and rules
- **generative**: Creative expansion within constitutional boundaries`;
  }

  private generateAgentSpecificSection(agent: AgentInstructionTemplate): string {
    let section = `## üéØ ${this.formatAgentName(agent.agent)} Specific Guidance

### Your Capabilities
- **Languages**: ${agent.capabilities.join(', ')}
- **Specializations**: ${agent.specializations.join(', ')}
- **Coordination**: ${agent.coordination ? 'Multi-agent coordination supported' : 'Single-agent mode only'}

### Your Role in Multi-Agent Workflows`;

    if (agent.coordination) {
      section += `
When working in coordinated environments:
- Recognize handoff triggers and coordination strategies
- Emit clear completion signals for downstream agents
- Provide detailed context during agent transitions
- Validate your output meets coordination requirements`;
    } else {
      section += `
Your agent operates in single-agent mode:
- Focus on independent task completion
- Ensure all outputs are self-contained
- Document any dependencies for manual coordination`;
    }

    return section;
  }

  private generateBlueprintSection(): string {
    return `## üèóÔ∏è Blueprint Compliance

### Mandatory Blueprint Structure
Every blueprint must include:

\`\`\`yaml
id: feat-feature-name
name: Human Readable Feature Name
version: 1.0.0
requiredRoutes: []
requiredProviders: []
requiredSelectors: []
ruleContracts:
  - id: validation-rule
    version: "2.5.0"
    description: "Rule description"
observability:
  events: []
errorStates: []
\`\`\`

### Blueprint Annotation Pattern
Always include in generated files:
\`\`\`markdown
<!--
@aegisBlueprint: feat-feature-name
@version: ${this.currentVersion}
@mode: lean|strict|generative
@intent: Brief description of generated content
@context: Relevant blueprint context
-->
\`\`\``;
  }

  private generateObservabilitySection(features: string[]): string {
    let section = `## üìä Observability Requirements

### Event Emission
Emit telemetry for all significant operations:
\`\`\`typescript
// Example event emission
emit('blueprint_generation_start', {
  blueprintId: 'feat-user-auth',
  agentId: '${this.getDefaultAgentTemplates()[0].agent}',
  mode: 'strict'
});
\`\`\``;

    if (features.includes('mcp-metadata')) {
      section += `

### MCP Metadata Emission
Always emit MCP metadata for observability:
\`\`\`yaml
observability:
  mcpContext:
    modelProvider: "openai"
    modelVersion: "gpt-4"
    contextTokens: 4096
    responseTokens: 1024
    temperature: 0.1
    timestamp: "${new Date().toISOString()}"
    sessionId: "aegis-session-12345"
    blueprintHash: "sha256:abc123..."
\`\`\``;
    }

    if (features.includes('drift-logging')) {
      section += `

### Drift Detection & Response
Monitor for these drift patterns:
- **Semantic Drift**: Output doesn't match blueprint intent
- **Regression**: Previously working functionality breaks
- **Hallucination**: Generated content has factual errors
- **Performance**: Significant speed or quality degradation

\`\`\`bash
# If drift detected, log immediately
aegis drift log --type=semantic_drift --severity=medium --blueprint=feat-user-auth
\`\`\``;
    }

    return section;
  }

  private generateCLISection(): string {
    return `## üõ†Ô∏è CLI Integration

### Blueprint Management
\`\`\`bash
# Initialize new blueprint
aegis blueprint init feat-new-feature --agent=${this.getDefaultAgentTemplates()[0].agent}

# Validate before generation
aegis blueprint validate feat-new-feature

# Generate with mode specification
aegis generate feat-new-feature --mode=strict --agent=${this.getDefaultAgentTemplates()[0].agent}
\`\`\`

### Essential Commands
\`\`\`bash
# Blueprint workflow
aegis blueprint init <name>
aegis generate <blueprint> --mode=strict
aegis test snapshot <blueprint>

# Multi-agent coordination
aegis agent handoff --to=<agent> --context="<message>"
aegis drift log --type=<type> --severity=<level>
\`\`\``;
  }

  private generateValidationSection(): string {
    return `## üîç Validation & Testing

### Snapshot Test Integration
Ensure generated code passes snapshot validation:
\`\`\`bash
# Run framework snapshot tests
npm test -- tests/snapshot-tests/

# Validate specific blueprint
aegis test snapshot feat-user-auth
\`\`\`

### Constitutional Requirements
- ‚úÖ Blueprint specification exists
- ‚úÖ Mandatory annotations included
- ‚úÖ MCP metadata emitted (if applicable)
- ‚úÖ Error states implemented
- ‚úÖ Observability events configured`;
  }

  private generateReferenceSection(): string {
    return `## üìö Knowledge Base

### Key Resources
- \`framework/framework-core-v2.5.0.md\`: Core specification
- \`CONSTITUTION.md\`: Foundational principles
- \`framework/agent-manifest.json\`: Agent capabilities

### Blueprint Examples
- \`blueprints/feat-public-viewing/\`: Working blueprint example
- \`scaffolds/web-app-starter/\`: Scaffold pattern reference`;
  }

  public async generateForAgent(agentId: string): Promise<void> {
    const agents = this.getAgentCapabilities();
    const agent = agents.find(a => a.agent === agentId);

    if (!agent) {
      throw new Error(`Agent ${agentId} not found in manifest`);
    }

    const content = this.generateInstructionContent(agent);
    const filename = `instructions-${agentId}-v${this.currentVersion}.md`;
    const filePath = path.join(this.versionsDir, filename);

    fs.writeFileSync(filePath, content);
    console.log(`‚úÖ Generated instructions for ${agentId}: ${filename}`);
  }

  public async generateForAllAgents(): Promise<void> {
    const agents = this.getAgentCapabilities();

    for (const agent of agents) {
      await this.generateForAgent(agent.agent);
    }

    // Also generate a generic version
    const genericContent = this.generateInstructionContent({
      agent: 'generic-ai-agent',
      capabilities: ['typescript', 'python', 'javascript'],
      specializations: ['full-stack', 'documentation'],
      coordination: true,
    });

    const genericFilename = `instructions-v${this.currentVersion}.md`;
    const genericPath = path.join(this.versionsDir, genericFilename);
    fs.writeFileSync(genericPath, genericContent);
    console.log(`‚úÖ Generated generic instructions: ${genericFilename}`);
  }

  public listVersions(): void {
    const files = fs
      .readdirSync(this.versionsDir)
      .filter((f: string) => f.startsWith('instructions-') && f.endsWith('.md'))
      .sort();

    console.log('üìã Available instruction versions:');
    files.forEach((file: string) => {
      const version = file.match(/v(\d+\.\d+\.\d+)/)?.[1] || 'unknown';
      const agent = file.replace('instructions-', '').replace(`-v${version}.md`, '').replace('.md', '');
      console.log(`  - ${agent}: v${version}`);
    });
  }
}

// CLI Interface
async function main() {
  const args = process.argv.slice(2);
  const generator = new VersionedInstructionGenerator();

  if (args.length === 0) {
    console.log('ü§ñ Aegis Framework Agent Instruction Generator');
    console.log('');
    console.log('Usage:');
    console.log('  node generate-agent-instructions.ts all           # Generate for all agents');
    console.log('  node generate-agent-instructions.ts <agent-id>    # Generate for specific agent');
    console.log('  node generate-agent-instructions.ts list          # List existing versions');
    console.log('');
    console.log('Examples:');
    console.log('  node generate-agent-instructions.ts github-copilot');
    console.log('  node generate-agent-instructions.ts claude-3-5-sonnet');
    return;
  }

  const command = args[0];

  try {
    switch (command) {
      case 'all':
        await generator.generateForAllAgents();
        break;
      case 'list':
        generator.listVersions();
        break;
      default:
        await generator.generateForAgent(command);
        break;
    }
  } catch (error) {
    console.error('‚ùå Error:', error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

// Check if this module is being run directly
if (process.argv[1] && process.argv[1].endsWith('generate-agent-instructions.ts')) {
  main();
}

module.exports = { VersionedInstructionGenerator };
