#!/usr/bin/env node

/**
 * @aegisFrameworkVersion: 2.4.0
 * @intent: CLI tool for generating versioned agent instructions
 * @context: Automatically creates agent-specific instructions based on current framework state
 */

const fs = require('fs');
const path = require('path');

class VersionedInstructionGenerator {
  constructor() {
    this.frameworkRoot = path.resolve(__dirname, '..');
    this.versionsDir = path.join(this.frameworkRoot, 'framework', 'versions');
    this.currentVersion = this.getCurrentVersion();
  }

  getCurrentVersion() {
    const versionPath = path.join(this.frameworkRoot, 'VERSION');
    return fs.readFileSync(versionPath, 'utf8').trim();
  }

  getFrameworkFeatures() {
    const features = [];
    
    // Check for core alpha features
    if (fs.existsSync(path.join(this.frameworkRoot, 'framework', 'framework-core-v1.0.0-alpha.md'))) {
      features.push('blueprint-driven-development', 'constitutional-governance', 'semantic-versioning');
    }

    // Check for beta features (multi-agent)
    if (fs.existsSync(path.join(this.versionsDir, 'framework-core-v1.1.0-beta-spec.md'))) {
      features.push('multi-agent-orchestration', 'mcp-metadata', 'drift-logging', 'adapter-interface');
    }

    // Check for apprenticeship features
    if (fs.existsSync(path.join(this.frameworkRoot, 'cli', 'apprenticeship-cli.ts'))) {
      features.push('apprenticeship-scaffolds', 'mentor-system', 'learning-integration');
    }

    // Check for observability features
    if (fs.existsSync(path.join(this.frameworkRoot, 'framework', 'observability'))) {
      features.push('advanced-observability', 'event-emission', 'telemetry');
    }

    return features;
  }

  getAgentCapabilities() {
    const manifestPath = path.join(this.frameworkRoot, 'framework', 'agent-manifest.json');
    
    if (!fs.existsSync(manifestPath)) {
      return this.getDefaultAgentTemplates();
    }

    try {
      const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
      return Object.values(manifest.agents || {}).map((agent) => ({
        agent: agent.agentId,
        capabilities: agent.capabilities?.languages || [],
        specializations: agent.capabilities?.specializations || [],
        coordination: agent.coordinationSupport?.handoffs || false
      }));
    } catch (error) {
      console.warn('Failed to parse agent manifest, using defaults');
      return this.getDefaultAgentTemplates();
    }
  }

  getDefaultAgentTemplates() {
    return [
      {
        agent: 'github-copilot',
        capabilities: ['typescript', 'python', 'go', 'javascript'],
        specializations: ['full-stack', 'documentation', 'testing'],
        coordination: true
      },
      {
        agent: 'claude-3-5-sonnet',
        capabilities: ['typescript', 'python', 'rust'],
        specializations: ['architecture', 'analysis', 'planning'],
        coordination: true
      },
      {
        agent: 'cursor',
        capabilities: ['typescript', 'javascript', 'css'],
        specializations: ['frontend', 'ui-components', 'styling'],
        coordination: true
      }
    ];
  }

  formatAgentName(agentId) {
    return agentId.split('-').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  }

  generateInstructionContent(agent) {
    const features = this.getFrameworkFeatures();
    
    return `<!--
@aegisFrameworkVersion: ${this.currentVersion}
@intent: Versioned ${agent.agent} agent instructions for current framework state
@context: ${features.join(', ')}
@target: ${agent.agent}
@generatedFrom: Auto-generated by generate-agent-instructions.js
-->

# ü§ñ ${this.formatAgentName(agent.agent)} Instructions for Aegis Framework v${this.currentVersion}

> **Agent-specific guidance for ${this.formatAgentName(agent.agent)} working within the Aegis Framework ecosystem.**

## üèõÔ∏è Constitutional Compliance

**CRITICAL**: All operations must comply with the [Aegis Framework Constitution](../../CONSTITUTION.md). This includes:

- **Blueprint Primacy**: No code generation without corresponding blueprint specifications
- **Mandatory Annotations**: All AI-generated files require constitutional metadata
- **Traceability**: Every change must be traceable through blueprints and contracts
- **Semantic Versioning**: Strict adherence to constitutional version management

## üéØ Framework Context (v${this.currentVersion})

### Current Capabilities
- **Core**: Blueprint-driven development with v1.0.0-alpha specification
- **Multi-Agent**: v1.1.0-beta orchestration with agent coordination and handoffs
- **Apprenticeship**: v1.3.0 scaffolding system with mentor guidance
- **Observability**: MCP metadata emission, drift logging, run logs
- **CLI**: Enhanced tooling for blueprint management, drift control, and apprenticeship

### Execution Modes
- **lean**: Minimal implementation focusing on core requirements
- **strict**: Full compliance with all blueprint contracts and rules
- **generative**: Creative expansion within constitutional boundaries

## üéØ ${this.formatAgentName(agent.agent)} Specific Guidance

### Your Capabilities
- **Languages**: ${agent.capabilities.join(', ')}
- **Specializations**: ${agent.specializations.join(', ')}
- **Coordination**: ${agent.coordination ? 'Multi-agent coordination supported' : 'Single-agent mode only'}

### Your Role in Multi-Agent Workflows
${agent.coordination ? `
When working in coordinated environments:
- Recognize handoff triggers and coordination strategies
- Emit clear completion signals for downstream agents
- Provide detailed context during agent transitions
- Validate your output meets coordination requirements` : `
Your agent operates in single-agent mode:
- Focus on independent task completion
- Ensure all outputs are self-contained
- Document any dependencies for manual coordination`}

## üîÅ Multi-Agent Orchestration Protocol

### Agent Coordination Awareness
When working in multi-agent environments:

\`\`\`yaml
# Recognize your role in blueprint coordination
agents:
  primary: ${agent.agent}
  specialized:
    - agent: cursor
      role: frontend-components
      scope: ["src/components/**"]
coordination:
  strategy: sequential
  handoff:
    - from: ${agent.agent}
      to: cursor
      trigger: "backend services complete"
\`\`\`

### Handoff Protocols
- **Before Handoff**: Emit clear completion signals and context
- **Context Transfer**: Provide detailed state and next steps
- **Validation**: Ensure your output meets handoff trigger conditions

## üèóÔ∏è Blueprint Compliance

### Mandatory Blueprint Structure
Every blueprint must include:

\`\`\`yaml
id: feat-feature-name
name: Human Readable Feature Name
version: 1.0.0
requiredRoutes: []
requiredProviders: []
requiredSelectors: []
ruleContracts:
  - id: validation-rule
    version: "1.0.0"
    description: "Rule description"
observability:
  events: []
errorStates: []
\`\`\`

### Blueprint Annotation Pattern
Always include in generated files:
\`\`\`markdown
<!--
@aegisBlueprint: feat-feature-name
@version: ${this.currentVersion}
@mode: lean|strict|generative
@intent: Brief description of generated content
@context: Relevant blueprint context
-->
\`\`\`

## üìÑ MCP Metadata Emission

### Required MCP Context
Always emit MCP metadata for observability:

\`\`\`yaml
observability:
  mcpContext:
    modelProvider: "openai"
    modelVersion: "gpt-4"
    contextTokens: 4096
    responseTokens: 1024
    temperature: 0.1
    timestamp: "${new Date().toISOString()}"
    sessionId: "aegis-session-12345"
    blueprintHash: "sha256:abc123..."
\`\`\`

### Event Emission Points
\`\`\`yaml
events:
  - name: mcp_execution_start
    context: { blueprintId: string, agentId: "${agent.agent}" }
    mcpFields: ["modelProvider", "contextTokens"]
  - name: mcp_execution_complete
    context: { outputMode: string, tokenUsage: number }
    mcpFields: ["responseTokens", "temperature"]
\`\`\`

## üß† Drift Detection & Response

### Drift Awareness
Monitor for these drift patterns:
- **Semantic Drift**: Output doesn't match blueprint intent
- **Regression**: Previously working functionality breaks
- **Hallucination**: Generated content has factual errors
- **Performance**: Significant speed or quality degradation

### Drift Response Protocol
\`\`\`bash
# If drift detected, log immediately
aegis drift log --type=semantic_drift --severity=medium --blueprint=feat-user-auth

# Request human review for critical drift
aegis drift escalate --severity=critical --assignee=developer@company.com
\`\`\`

## üõ†Ô∏è CLI Integration

### Blueprint Management
\`\`\`bash
# Initialize new blueprint
aegis blueprint init feat-new-feature --agent=${agent.agent}

# Validate before generation
aegis blueprint validate feat-new-feature

# Generate with mode specification
aegis generate feat-new-feature --mode=strict --agent=${agent.agent}
\`\`\`

### Essential Commands
\`\`\`bash
# Blueprint workflow
aegis blueprint init <name>
aegis generate <blueprint> --mode=strict
aegis test snapshot <blueprint>

# Multi-agent coordination
aegis agent handoff --to=<agent> --context="<message>"
aegis drift log --type=<type> --severity=<level>
\`\`\`

## üîç Validation & Testing

### Snapshot Test Integration
Ensure generated code passes snapshot validation:
\`\`\`bash
# Run framework snapshot tests
npm test -- tests/snapshot-tests/

# Validate specific blueprint
aegis test snapshot feat-user-auth
\`\`\`

### Constitutional Requirements
- ‚úÖ Blueprint specification exists
- ‚úÖ Mandatory annotations included
- ‚úÖ MCP metadata emitted
- ‚úÖ Error states implemented
- ‚úÖ Observability events configured

## üìö Knowledge Base

### Key Resources
- \`framework/framework-core-v1.0.0-alpha.md\`: Core specification
- \`framework/versions/framework-core-v1.1.0-beta-spec.md\`: Multi-agent features
- \`CONSTITUTION.md\`: Foundational principles
- \`framework/agent-manifest.json\`: Agent capabilities

### Blueprint Examples
- \`blueprints/feat-public-viewing/\`: Working multi-agent example
- \`scaffolds/web-app-starter/\`: Apprenticeship scaffold pattern

---

## üéØ Quick Reference

### Essential Commands
\`\`\`bash
# Blueprint workflow
aegis blueprint init <name>
aegis generate <blueprint> --mode=strict
aegis test snapshot <blueprint>

# Multi-agent coordination
aegis agent handoff --to=<agent> --context="<message>"
aegis drift log --type=<type> --severity=<level>

# Apprenticeship
aegis apprentice start --scaffold=<name>
aegis apprentice submit --component=<name>
\`\`\`

### Constitutional Requirements
- ‚úÖ Blueprint specification exists
- ‚úÖ Mandatory annotations included
- ‚úÖ MCP metadata emitted
- ‚úÖ Error states implemented
- ‚úÖ Observability events configured

---

**Version**: ${this.currentVersion}  
**Last Updated**: ${new Date().toISOString().split('T')[0]}  
**Target Agent**: ${this.formatAgentName(agent.agent)}  
**Framework Authority**: Aegis Framework Constitution`;
  }

  async generateForAgent(agentId) {
    const agents = this.getAgentCapabilities();
    const agent = agents.find(a => a.agent === agentId);
    
    if (!agent) {
      throw new Error(`Agent ${agentId} not found in manifest`);
    }

    const content = this.generateInstructionContent(agent);
    const filename = `instructions-${agentId}-v${this.currentVersion}.md`;
    const filePath = path.join(this.versionsDir, filename);

    fs.writeFileSync(filePath, content);
    console.log(`‚úÖ Generated instructions for ${agentId}: ${filename}`);
  }

  async generateForAllAgents() {
    const agents = this.getAgentCapabilities();
    
    for (const agent of agents) {
      await this.generateForAgent(agent.agent);
    }

    // Also generate a generic version
    const genericContent = this.generateInstructionContent({
      agent: 'generic-ai-agent',
      capabilities: ['typescript', 'python', 'javascript'],
      specializations: ['full-stack', 'documentation'],
      coordination: true
    });

    const genericFilename = `instructions-v${this.currentVersion}.md`;
    const genericPath = path.join(this.versionsDir, genericFilename);
    fs.writeFileSync(genericPath, genericContent);
    console.log(`‚úÖ Generated generic instructions: ${genericFilename}`);
  }

  listVersions() {
    const files = fs.readdirSync(this.versionsDir)
      .filter(f => f.startsWith('instructions-') && f.endsWith('.md'))
      .sort();

    console.log('üìã Available instruction versions:');
    files.forEach(file => {
      const version = file.match(/v(\d+\.\d+\.\d+)/)?.[1] || 'unknown';
      const agent = file.replace('instructions-', '').replace(`-v${version}.md`, '').replace('.md', '');
      console.log(`  - ${agent}: v${version}`);
    });
  }
}

// CLI Interface
async function main() {
  const args = process.argv.slice(2);
  const generator = new VersionedInstructionGenerator();

  if (args.length === 0) {
    console.log('ü§ñ Aegis Framework Agent Instruction Generator');
    console.log('');
    console.log('Usage:');
    console.log('  node generate-agent-instructions.js all           # Generate for all agents');
    console.log('  node generate-agent-instructions.js <agent-id>    # Generate for specific agent');
    console.log('  node generate-agent-instructions.js list          # List existing versions');
    console.log('');
    console.log('Examples:');
    console.log('  node generate-agent-instructions.js github-copilot');
    console.log('  node generate-agent-instructions.js claude-3-5-sonnet');
    return;
  }

  const command = args[0];

  try {
    switch (command) {
      case 'all':
        await generator.generateForAllAgents();
        break;
      case 'list':
        generator.listVersions();
        break;
      default:
        await generator.generateForAgent(command);
        break;
    }
  } catch (error) {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
  }
}

// Check if this module is being run directly
if (require.main === module) {
  main();
}

module.exports = { VersionedInstructionGenerator };
