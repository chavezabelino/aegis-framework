#!/usr/bin/env node

/**
 * @aegisFrameworkVersion: 2.5.0
 * @intent: Drift monitoring dashboard with team configuration support
 * @context: Visual insights into framework health and drift patterns
 * @mode: strict
 */

import fs from 'fs';
import path from 'path';
import { TeamConfigLoader } from './team-config-loader.js';
import { EvolutionStoryDetector } from './detect-evolution-stories.js';
import { AnnotationValidator } from './validate-annotations.js';
import { TemplateQualityValidator } from './validate-template-quality.js';

interface DashboardMetrics {
  evolutionStories: {
    total: number;
    recent: number;
    critical: number;
    autoGenerated: number;
  };
  annotations: {
    coverage: number;
    violations: number;
    criticalViolations: number;
  };
  templateQuality: {
    overallScore: number;
    encodingScore: number;
    structureScore: number;
    fidelityScore: number;
  };
  constitutionalCompliance: {
    violations: number;
    warnings: number;
    lastCheck: Date;
  };
  driftIndicators: {
    agentDrift: number;
    documentationDrift: number;
    frameworkDrift: number;
    userWorkflowDrift: number;
  };
}

interface DashboardConfig {
  updateInterval: 'hourly' | 'daily' | 'weekly';
  includeEvolutionStories: boolean;
  includeAnnotations: boolean;
  includeTemplateQuality: boolean;
  includeConstitutionalCompliance: boolean;
  includeDriftIndicators: boolean;
}

class DriftMonitoringDashboard {
  private configLoader: TeamConfigLoader;
  private projectRoot: string;
  private dashboardPath: string;

  constructor(projectRoot: string = process.cwd()) {
    this.projectRoot = projectRoot;
    this.configLoader = TeamConfigLoader.getInstance(projectRoot);
    this.dashboardPath = path.join(projectRoot, '.framework', 'drift-dashboard.json');
  }

  /**
   * Generate comprehensive dashboard metrics
   */
  async generateDashboard(): Promise<DashboardMetrics | null> {
    // Check if drift monitoring dashboard is enabled
    if (!this.configLoader.isOptionalFeatureEnabled('driftMonitoringDashboard')) {
      console.log('üìã Drift monitoring dashboard disabled in team configuration');
      return null;
    }

    const config = this.configLoader.loadConfig();
    const dashboardConfig: DashboardConfig = {
      updateInterval: config?.optional.driftMonitoringDashboard.updateInterval ?? 'daily',
      includeEvolutionStories: true,
      includeAnnotations: true,
      includeTemplateQuality: true,
      includeConstitutionalCompliance: true,
      includeDriftIndicators: true,
    };

    console.log('üìä Generating Drift Monitoring Dashboard...\n');

    const metrics: DashboardMetrics = {
      evolutionStories: { total: 0, recent: 0, critical: 0, autoGenerated: 0 },
      annotations: { coverage: 0, violations: 0, criticalViolations: 0 },
      templateQuality: { overallScore: 0, encodingScore: 0, structureScore: 0, fidelityScore: 0 },
      constitutionalCompliance: { violations: 0, warnings: 0, lastCheck: new Date() },
      driftIndicators: { agentDrift: 0, documentationDrift: 0, frameworkDrift: 0, userWorkflowDrift: 0 },
    };

    // Collect evolution story metrics
    if (dashboardConfig.includeEvolutionStories) {
      metrics.evolutionStories = await this.collectEvolutionStoryMetrics();
    }

    // Collect annotation metrics
    if (dashboardConfig.includeAnnotations) {
      metrics.annotations = await this.collectAnnotationMetrics();
    }

    // Collect template quality metrics
    if (dashboardConfig.includeTemplateQuality) {
      metrics.templateQuality = await this.collectTemplateQualityMetrics();
    }

    // Collect constitutional compliance metrics
    if (dashboardConfig.includeConstitutionalCompliance) {
      metrics.constitutionalCompliance = await this.collectConstitutionalComplianceMetrics();
    }

    // Collect drift indicators
    if (dashboardConfig.includeDriftIndicators) {
      metrics.driftIndicators = await this.collectDriftIndicators();
    }

    // Save dashboard data
    await this.saveDashboard(metrics);

    // Display dashboard
    this.displayDashboard(metrics);

    return metrics;
  }

  /**
   * Collect evolution story metrics
   */
  private async collectEvolutionStoryMetrics(): Promise<DashboardMetrics['evolutionStories']> {
    try {
      const evolutionDir = path.join(this.projectRoot, 'docs', 'evolution');
      if (!fs.existsSync(evolutionDir)) {
        return { total: 0, recent: 0, critical: 0, autoGenerated: 0 };
      }

      const files = fs.readdirSync(evolutionDir).filter(f => f.endsWith('.md'));
      const total = files.length;

      // Count recent stories (last 7 days)
      const oneWeekAgo = new Date();
      oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

      let recent = 0;
      let critical = 0;
      let autoGenerated = 0;

      for (const file of files) {
        const filePath = path.join(evolutionDir, file);
        const stats = fs.statSync(filePath);
        const content = fs.readFileSync(filePath, 'utf8');

        if (stats.mtime > oneWeekAgo) {
          recent++;
        }

        if (content.includes('impactLevel: "critical"') || content.includes('severity: "critical"')) {
          critical++;
        }

        if (file.includes('auto-generated') || content.includes('auto-detected')) {
          autoGenerated++;
        }
      }

      return { total, recent, critical, autoGenerated };
    } catch (error) {
      console.warn('Failed to collect evolution story metrics:', error);
      return { total: 0, recent: 0, critical: 0, autoGenerated: 0 };
    }
  }

  /**
   * Collect annotation metrics
   */
  private async collectAnnotationMetrics(): Promise<DashboardMetrics['annotations']> {
    try {
      const validator = new AnnotationValidator(this.projectRoot);
      const result = await validator.validateAll();

      return {
        coverage: result.coverage,
        violations: result.violations.length,
        criticalViolations: result.violations.filter(v => v.severity === 'critical').length,
      };
    } catch (error) {
      console.warn('Failed to collect annotation metrics:', error);
      return { coverage: 0, violations: 0, criticalViolations: 0 };
    }
  }

  /**
   * Collect template quality metrics
   */
  private async collectTemplateQualityMetrics(): Promise<DashboardMetrics['templateQuality']> {
    try {
      const validator = new TemplateQualityValidator(this.projectRoot);
      const result = await validator.validateAll();

      return {
        overallScore: result.overall,
        encodingScore: result.encoding.score,
        structureScore: result.structure.score,
        fidelityScore: result.fidelity.score,
      };
    } catch (error) {
      console.warn('Failed to collect template quality metrics:', error);
      return { overallScore: 0, encodingScore: 0, structureScore: 0, fidelityScore: 0 };
    }
  }

  /**
   * Collect constitutional compliance metrics
   */
  private async collectConstitutionalComplianceMetrics(): Promise<DashboardMetrics['constitutionalCompliance']> {
    try {
      // This would integrate with constitutional compliance tools
      // For now, return placeholder metrics
      return {
        violations: 0,
        warnings: 0,
        lastCheck: new Date(),
      };
    } catch (error) {
      console.warn('Failed to collect constitutional compliance metrics:', error);
      return { violations: 0, warnings: 0, lastCheck: new Date() };
    }
  }

  /**
   * Collect drift indicators
   */
  private async collectDriftIndicators(): Promise<DashboardMetrics['driftIndicators']> {
    try {
      // This would integrate with drift detection tools
      // For now, return placeholder metrics
      return {
        agentDrift: 0,
        documentationDrift: 0,
        frameworkDrift: 0,
        userWorkflowDrift: 0,
      };
    } catch (error) {
      console.warn('Failed to collect drift indicators:', error);
      return { agentDrift: 0, documentationDrift: 0, frameworkDrift: 0, userWorkflowDrift: 0 };
    }
  }

  /**
   * Save dashboard data
   */
  private async saveDashboard(metrics: DashboardMetrics): Promise<void> {
    try {
      const dashboardData = {
        generatedAt: new Date().toISOString(),
        metrics,
        config: this.configLoader.loadConfig()?.optional.driftMonitoringDashboard,
      };

      const dashboardDir = path.dirname(this.dashboardPath);
      if (!fs.existsSync(dashboardDir)) {
        fs.mkdirSync(dashboardDir, { recursive: true });
      }

      fs.writeFileSync(this.dashboardPath, JSON.stringify(dashboardData, null, 2));
    } catch (error) {
      console.warn('Failed to save dashboard data:', error);
    }
  }

  /**
   * Display dashboard in console
   */
  private displayDashboard(metrics: DashboardMetrics): void {
    console.log('üìä Drift Monitoring Dashboard');
    console.log('=============================\n');

    // Evolution Stories Section
    console.log('üìù Evolution Stories');
    console.log(`   Total: ${metrics.evolutionStories.total}`);
    console.log(`   Recent (7 days): ${metrics.evolutionStories.recent}`);
    console.log(`   Critical: ${metrics.evolutionStories.critical}`);
    console.log(`   Auto-generated: ${metrics.evolutionStories.autoGenerated}\n`);

    // Annotations Section
    console.log('üè∑Ô∏è Annotations');
    console.log(`   Coverage: ${(metrics.annotations.coverage * 100).toFixed(1)}%`);
    console.log(`   Violations: ${metrics.annotations.violations}`);
    console.log(`   Critical Violations: ${metrics.annotations.criticalViolations}\n`);

    // Template Quality Section
    console.log('üìã Template Quality');
    console.log(`   Overall Score: ${metrics.templateQuality.overallScore}/100`);
    console.log(`   Encoding Score: ${metrics.templateQuality.encodingScore}/100`);
    console.log(`   Structure Score: ${metrics.templateQuality.structureScore}/100`);
    console.log(`   Fidelity Score: ${metrics.templateQuality.fidelityScore}/100\n`);

    // Constitutional Compliance Section
    console.log('‚öñÔ∏è Constitutional Compliance');
    console.log(`   Violations: ${metrics.constitutionalCompliance.violations}`);
    console.log(`   Warnings: ${metrics.constitutionalCompliance.warnings}`);
    console.log(`   Last Check: ${metrics.constitutionalCompliance.lastCheck.toLocaleString()}\n`);

    // Drift Indicators Section
    console.log('üìà Drift Indicators');
    console.log(`   Agent Drift: ${metrics.driftIndicators.agentDrift}`);
    console.log(`   Documentation Drift: ${metrics.driftIndicators.documentationDrift}`);
    console.log(`   Framework Drift: ${metrics.driftIndicators.frameworkDrift}`);
    console.log(`   User Workflow Drift: ${metrics.driftIndicators.userWorkflowDrift}\n`);

    // Health Summary
    const healthScore = this.calculateHealthScore(metrics);
    console.log('üè• Framework Health Summary');
    console.log(`   Overall Health: ${healthScore}/100`);
    console.log(`   Status: ${this.getHealthStatus(healthScore)}\n`);

    console.log(`üìÑ Dashboard saved to: ${this.dashboardPath}`);
  }

  /**
   * Calculate overall health score
   */
  private calculateHealthScore(metrics: DashboardMetrics): number {
    const annotationHealth = metrics.annotations.coverage * 100;
    const templateHealth = metrics.templateQuality.overallScore;
    const complianceHealth = metrics.constitutionalCompliance.violations === 0 ? 100 : 50;

    return Math.round((annotationHealth + templateHealth + complianceHealth) / 3);
  }

  /**
   * Get health status based on score
   */
  private getHealthStatus(score: number): string {
    if (score >= 90) return 'üü¢ Excellent';
    if (score >= 80) return 'üü° Good';
    if (score >= 70) return 'üü† Fair';
    return 'üî¥ Needs Attention';
  }

  /**
   * Get dashboard data
   */
  async getDashboardData(): Promise<any> {
    if (!fs.existsSync(this.dashboardPath)) {
      return null;
    }

    try {
      const data = fs.readFileSync(this.dashboardPath, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      console.warn('Failed to read dashboard data:', error);
      return null;
    }
  }
}

// CLI interface
async function main(): Promise<void> {
  const dashboard = new DriftMonitoringDashboard();
  await dashboard.generateDashboard();
}

// Run if called directly
if (process.argv[1] && process.argv[1].endsWith('drift-monitoring-dashboard.ts')) {
  main().catch(error => {
    console.error('Dashboard generation error:', error);
    process.exit(1);
  });
}

export { DriftMonitoringDashboard };
