/**
 * @aegisFrameworkVersion: 2.3.0
 * @intent: Integration tests for Phase 3 feature configurability tools
 * @context: Validate optional features integration with team configuration
 * @mode: strict
 */

import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import { RealTimeEvolutionDetector } from '../tools/realtime-evolution-detection.js';
import { DriftMonitoringDashboard } from '../tools/drift-monitoring-dashboard.js';

describe('Feature Configurability Phase 3 Integration', () => {
  let testProjectRoot: string;
  let configPath: string;

  beforeEach(() => {
    // Create temporary test directory
    testProjectRoot = fs.mkdtempSync(path.join(process.cwd(), 'test-phase3-'));
    configPath = path.join(testProjectRoot, '.framework', 'team-config.yaml');
    
    // Ensure .framework directory exists
    fs.mkdirSync(path.dirname(configPath), { recursive: true });
    
    // Create mock git repository
    const gitDir = path.join(testProjectRoot, '.git');
    fs.mkdirSync(gitDir, { recursive: true });
    fs.writeFileSync(path.join(gitDir, 'HEAD'), 'ref: refs/heads/main');
    
    // Create docs/evolution directory
    const evolutionDir = path.join(testProjectRoot, 'docs', 'evolution');
    fs.mkdirSync(evolutionDir, { recursive: true });
  });

  afterEach(() => {
    // Clean up test directory
    if (fs.existsSync(testProjectRoot)) {
      fs.rmSync(testProjectRoot, { recursive: true, force: true });
    }
  });

  describe('Real-time Pattern Detection Integration', () => {
    it('should respect disabled real-time pattern detection', async () => {
      const disabledConfig = {
        team: { name: 'Test Team', profile: 'minimal' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: false, autoGenerate: false, triggerThreshold: 'high' },
          constitutionalEnforcement: { mode: 'advisory', blocking: false, autoCorrection: false },
          precommitHooks: { enabled: false, evolutionDetection: false, constitutionalValidation: false },
          annotations: { required: false, coverage: 0.5, enforcement: 'silent' },
          templateQuality: { validation: false, encodingChecks: false }
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'low' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'weekly' },
          automatedChangelog: { enabled: false, format: 'standard' },
          predictiveEnforcement: { enabled: false, confidence: 0.9, learning: false }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(disabledConfig));

      const detector = new RealTimeEvolutionDetector(testProjectRoot);
      const context = {
        userPrompt: 'does this break the framework?',
        aiResponse: 'No, this should be safe.',
        timestamp: new Date(),
        sessionId: 'test-session'
      };

      const triggers = await detector.analyzeConversationContext(context);
      
      // Should return empty array when disabled
      expect(triggers).toEqual([]);
    });

    it('should perform detection when enabled', async () => {
      const enabledConfig = {
        team: { name: 'Test Team', profile: 'strict' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: true, triggerThreshold: 'low' },
          constitutionalEnforcement: { mode: 'strict', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.9, enforcement: 'error' },
          templateQuality: { validation: true, encodingChecks: true }
        },
        optional: {
          realtimePatternDetection: { enabled: true, sensitivity: 'high' },
          autoGeneratedEvolutionStories: { enabled: true, severity: 'medium' },
          driftMonitoringDashboard: { enabled: true, updateInterval: 'hourly' },
          automatedChangelog: { enabled: true, format: 'constitutional' },
          predictiveEnforcement: { enabled: true, confidence: 0.7, learning: true }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(enabledConfig));

      const detector = new RealTimeEvolutionDetector(testProjectRoot);
      const context = {
        userPrompt: 'does this break the framework?',
        aiResponse: 'No, this should be safe.',
        timestamp: new Date(),
        sessionId: 'test-session'
      };

      const triggers = await detector.analyzeConversationContext(context);
      
      // Should perform actual detection when enabled
      expect(Array.isArray(triggers)).toBe(true);
    });

    it('should respect different sensitivity levels', async () => {
      const mediumConfig = {
        team: { name: 'Test Team', profile: 'balanced' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: false, triggerThreshold: 'medium' },
          constitutionalEnforcement: { mode: 'guided', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.8, enforcement: 'warning' },
          templateQuality: { validation: true, encodingChecks: true }
        },
        optional: {
          realtimePatternDetection: { enabled: true, sensitivity: 'medium' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'daily' },
          automatedChangelog: { enabled: false, format: 'constitutional' },
          predictiveEnforcement: { enabled: false, confidence: 0.8, learning: true }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(mediumConfig));

      const detector = new RealTimeEvolutionDetector(testProjectRoot);
      const context = {
        userPrompt: 'assess the pitfall in this approach',
        aiResponse: 'This approach has several potential issues.',
        timestamp: new Date(),
        sessionId: 'test-session'
      };

      const triggers = await detector.analyzeConversationContext(context);
      
      // Should perform detection with medium sensitivity
      expect(Array.isArray(triggers)).toBe(true);
    });
  });

  describe('Drift Monitoring Dashboard Integration', () => {
    beforeEach(() => {
      // Create some test evolution stories
      const evolutionDir = path.join(testProjectRoot, 'docs', 'evolution');
      const testStory = path.join(evolutionDir, 'test-story.md');
      fs.writeFileSync(testStory, `<!--
@aegisFrameworkVersion: 2.1.0
@intent: Test evolution story
@context: Testing dashboard integration
@mode: strict
-->

# Test Evolution Story

This is a test evolution story for dashboard metrics.
`);
    });

    it('should respect disabled drift monitoring dashboard', async () => {
      const disabledConfig = {
        team: { name: 'Test Team', profile: 'minimal' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: false, autoGenerate: false, triggerThreshold: 'high' },
          constitutionalEnforcement: { mode: 'advisory', blocking: false, autoCorrection: false },
          precommitHooks: { enabled: false, evolutionDetection: false, constitutionalValidation: false },
          annotations: { required: false, coverage: 0.5, enforcement: 'silent' },
          templateQuality: { validation: false, encodingChecks: false }
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'low' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'weekly' },
          automatedChangelog: { enabled: false, format: 'standard' },
          predictiveEnforcement: { enabled: false, confidence: 0.9, learning: false }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(disabledConfig));

      const dashboard = new DriftMonitoringDashboard(testProjectRoot);
      const metrics = await dashboard.generateDashboard();
      
      // Should return null when disabled
      expect(metrics).toBeNull();
    });

    it('should generate dashboard when enabled', async () => {
      const enabledConfig = {
        team: { name: 'Test Team', profile: 'strict' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: true, triggerThreshold: 'low' },
          constitutionalEnforcement: { mode: 'strict', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.9, enforcement: 'error' },
          templateQuality: { validation: true, encodingChecks: true }
        },
        optional: {
          realtimePatternDetection: { enabled: true, sensitivity: 'high' },
          autoGeneratedEvolutionStories: { enabled: true, severity: 'medium' },
          driftMonitoringDashboard: { enabled: true, updateInterval: 'hourly' },
          automatedChangelog: { enabled: true, format: 'constitutional' },
          predictiveEnforcement: { enabled: true, confidence: 0.7, learning: true }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(enabledConfig));

      const dashboard = new DriftMonitoringDashboard(testProjectRoot);
      const metrics = await dashboard.generateDashboard();
      
      // Should generate dashboard when enabled
      expect(metrics).toBeDefined();
      expect(metrics?.evolutionStories.total).toBeGreaterThanOrEqual(0);
      expect(metrics?.annotations.coverage).toBeGreaterThanOrEqual(0);
      expect(metrics?.templateQuality.overallScore).toBeGreaterThanOrEqual(0);
    });

    it('should respect different update intervals', async () => {
      const dailyConfig = {
        team: { name: 'Test Team', profile: 'balanced' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: false, triggerThreshold: 'medium' },
          constitutionalEnforcement: { mode: 'guided', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.8, enforcement: 'warning' },
          templateQuality: { validation: true, encodingChecks: true }
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'medium' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: true, updateInterval: 'daily' },
          automatedChangelog: { enabled: false, format: 'constitutional' },
          predictiveEnforcement: { enabled: false, confidence: 0.8, learning: true }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(dailyConfig));

      const dashboard = new DriftMonitoringDashboard(testProjectRoot);
      const metrics = await dashboard.generateDashboard();
      
      // Should generate dashboard with daily interval
      expect(metrics).toBeDefined();
    });
  });

  describe('Cross-Optional Features Integration', () => {
    it('should work together with different configuration profiles', async () => {
      const balancedConfig = {
        team: { name: 'Test Team', profile: 'balanced' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: false, triggerThreshold: 'medium' },
          constitutionalEnforcement: { mode: 'guided', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.8, enforcement: 'warning' },
          templateQuality: { validation: true, encodingChecks: true }
        },
        optional: {
          realtimePatternDetection: { enabled: true, sensitivity: 'medium' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: true, updateInterval: 'daily' },
          automatedChangelog: { enabled: false, format: 'constitutional' },
          predictiveEnforcement: { enabled: false, confidence: 0.8, learning: true }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(balancedConfig));

      // Test all optional features together
      const detector = new RealTimeEvolutionDetector(testProjectRoot);
      const dashboard = new DriftMonitoringDashboard(testProjectRoot);

      const context = {
        userPrompt: 'field-driven approach for this feature',
        aiResponse: 'This would be a good field-driven approach.',
        timestamp: new Date(),
        sessionId: 'test-session'
      };

      const [triggers, metrics] = await Promise.all([
        detector.analyzeConversationContext(context),
        dashboard.generateDashboard()
      ]);

      // All optional features should respect the balanced configuration
      expect(Array.isArray(triggers)).toBe(true);
      expect(metrics).toBeDefined();
    });

    it('should handle all features disabled in minimal profile', async () => {
      const minimalConfig = {
        team: { name: 'Test Team', profile: 'minimal' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: false, autoGenerate: false, triggerThreshold: 'high' },
          constitutionalEnforcement: { mode: 'advisory', blocking: false, autoCorrection: false },
          precommitHooks: { enabled: false, evolutionDetection: false, constitutionalValidation: false },
          annotations: { required: false, coverage: 0.5, enforcement: 'silent' },
          templateQuality: { validation: false, encodingChecks: false }
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'low' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'weekly' },
          automatedChangelog: { enabled: false, format: 'standard' },
          predictiveEnforcement: { enabled: false, confidence: 0.9, learning: false }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(minimalConfig));

      // Test all optional features with minimal configuration
      const detector = new RealTimeEvolutionDetector(testProjectRoot);
      const dashboard = new DriftMonitoringDashboard(testProjectRoot);

      const context = {
        userPrompt: 'field-driven approach for this feature',
        aiResponse: 'This would be a good field-driven approach.',
        timestamp: new Date(),
        sessionId: 'test-session'
      };

      const [triggers, metrics] = await Promise.all([
        detector.analyzeConversationContext(context),
        dashboard.generateDashboard()
      ]);

      // All optional features should be disabled in minimal profile
      expect(triggers).toEqual([]);
      expect(metrics).toBeNull();
    });
  });
});
