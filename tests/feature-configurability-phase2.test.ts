/**
 * @aegisFrameworkVersion: 2.5.0
 * @intent: Integration tests for Phase 2 feature configurability tools
 * @context: Validate pre-commit hooks, template quality, and annotation validation
 * @mode: strict
 */

import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import { PreCommitHook } from '../tools/pre-commit-hook.js';
import { TemplateQualityValidator } from '../tools/validate-template-quality.js';
import { AnnotationValidator } from '../tools/validate-annotations.js';

describe('Feature Configurability Phase 2 Integration', () => {
  let testProjectRoot: string;
  let configPath: string;

  beforeEach(() => {
    // Create temporary test directory
    testProjectRoot = fs.mkdtempSync(path.join(process.cwd(), 'test-phase2-'));
    configPath = path.join(testProjectRoot, '.framework', 'team-config.yaml');

    // Ensure .framework directory exists
    fs.mkdirSync(path.dirname(configPath), { recursive: true });

    // Create mock git repository
    const gitDir = path.join(testProjectRoot, '.git');
    fs.mkdirSync(gitDir, { recursive: true });
    fs.writeFileSync(path.join(gitDir, 'HEAD'), 'ref: refs/heads/main');
  });

  afterEach(() => {
    // Clean up test directory
    if (fs.existsSync(testProjectRoot)) {
      fs.rmSync(testProjectRoot, { recursive: true, force: true });
    }
  });

  describe('Pre-commit Hook Integration', () => {
    it('should respect disabled pre-commit hooks', async () => {
      const disabledConfig = {
        team: { name: 'Test Team', profile: 'minimal' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true,
        },
        required: {
          evolutionStoryDetection: { enabled: false, autoGenerate: false, triggerThreshold: 'high' },
          constitutionalEnforcement: { mode: 'advisory', blocking: false, autoCorrection: false },
          precommitHooks: { enabled: false, evolutionDetection: false, constitutionalValidation: false },
          annotations: { required: false, coverage: 0.5, enforcement: 'silent' },
          templateQuality: { validation: false, encodingChecks: false },
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'low' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'weekly' },
          automatedChangelog: { enabled: false, format: 'standard' },
          predictiveEnforcement: { enabled: false, confidence: 0.9, learning: false },
        },
      };

      fs.writeFileSync(configPath, yaml.dump(disabledConfig));

      const hook = new PreCommitHook(testProjectRoot);
      const result = await hook.run();

      expect(result.allowed).toBe(true);
      expect(result.violations).toEqual([]);
    });

    it('should respect different enforcement modes', async () => {
      const strictConfig = {
        team: { name: 'Test Team', profile: 'strict' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true,
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: true, triggerThreshold: 'low' },
          constitutionalEnforcement: { mode: 'strict', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.9, enforcement: 'error' },
          templateQuality: { validation: true, encodingChecks: true },
        },
        optional: {
          realtimePatternDetection: { enabled: true, sensitivity: 'high' },
          autoGeneratedEvolutionStories: { enabled: true, severity: 'medium' },
          driftMonitoringDashboard: { enabled: true, updateInterval: 'hourly' },
          automatedChangelog: { enabled: true, format: 'constitutional' },
          predictiveEnforcement: { enabled: true, confidence: 0.7, learning: true },
        },
      };

      fs.writeFileSync(configPath, yaml.dump(strictConfig));

      const hook = new PreCommitHook(testProjectRoot);
      const result = await hook.run();

      // Should be allowed since no actual violations exist
      expect(result.allowed).toBe(true);
    });
  });

  describe('Template Quality Validation Integration', () => {
    beforeEach(() => {
      // Create some test files for template validation
      const testDir = path.join(testProjectRoot, 'test-templates');
      fs.mkdirSync(testDir, { recursive: true });

      // Create a test markdown file
      const testFile = path.join(testDir, 'test.md');
      fs.writeFileSync(
        testFile,
        `<!--
@aegisFrameworkVersion: 2.5.0
@intent: Test template file
@context: Testing template quality validation
@mode: strict
-->

# Test Template

This is a test template file for validation.
`
      );
    });

    it('should respect disabled template quality validation', async () => {
      const disabledConfig = {
        team: { name: 'Test Team', profile: 'minimal' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true,
        },
        required: {
          evolutionStoryDetection: { enabled: false, autoGenerate: false, triggerThreshold: 'high' },
          constitutionalEnforcement: { mode: 'advisory', blocking: false, autoCorrection: false },
          precommitHooks: { enabled: false, evolutionDetection: false, constitutionalValidation: false },
          annotations: { required: false, coverage: 0.5, enforcement: 'silent' },
          templateQuality: { validation: false, encodingChecks: false },
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'low' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'weekly' },
          automatedChangelog: { enabled: false, format: 'standard' },
          predictiveEnforcement: { enabled: false, confidence: 0.9, learning: false },
        },
      };

      fs.writeFileSync(configPath, yaml.dump(disabledConfig));

      const validator = new TemplateQualityValidator(testProjectRoot);
      const result = await validator.validateAll();

      expect(result.overall).toBe(100);
      expect(result.violations).toEqual([]);
    });

    it('should perform validation when enabled', async () => {
      const enabledConfig = {
        team: { name: 'Test Team', profile: 'strict' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true,
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: true, triggerThreshold: 'low' },
          constitutionalEnforcement: { mode: 'strict', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.9, enforcement: 'error' },
          templateQuality: { validation: true, encodingChecks: true },
        },
        optional: {
          realtimePatternDetection: { enabled: true, sensitivity: 'high' },
          autoGeneratedEvolutionStories: { enabled: true, severity: 'medium' },
          driftMonitoringDashboard: { enabled: true, updateInterval: 'hourly' },
          automatedChangelog: { enabled: true, format: 'constitutional' },
          predictiveEnforcement: { enabled: true, confidence: 0.7, learning: true },
        },
      };

      fs.writeFileSync(configPath, yaml.dump(enabledConfig));

      const validator = new TemplateQualityValidator(testProjectRoot);
      const result = await validator.validateAll();

      // Should perform actual validation
      expect(result.overall).toBeGreaterThanOrEqual(0);
      expect(result.overall).toBeLessThanOrEqual(100);
    });
  });

  describe('Annotation Validation Integration', () => {
    beforeEach(() => {
      // Create test files for annotation validation
      const testDir = path.join(testProjectRoot, 'test-files');
      fs.mkdirSync(testDir, { recursive: true });

      // Create a file with proper annotations
      const properFile = path.join(testDir, 'proper.ts');
      fs.writeFileSync(
        properFile,
        `/**
 * @aegisFrameworkVersion: 2.5.0
 * @intent: Test file with proper annotations
 * @context: Testing annotation validation
 * @mode: strict
 */

export function testFunction() {
  return 'test';
}
`
      );

      // Create a file without annotations
      const missingFile = path.join(testDir, 'missing.ts');
      fs.writeFileSync(
        missingFile,
        `export function testFunction() {
  return 'test';
}
`
      );
    });

    it('should respect disabled annotation requirements', async () => {
      const disabledConfig = {
        team: { name: 'Test Team', profile: 'minimal' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true,
        },
        required: {
          evolutionStoryDetection: { enabled: false, autoGenerate: false, triggerThreshold: 'high' },
          constitutionalEnforcement: { mode: 'advisory', blocking: false, autoCorrection: false },
          precommitHooks: { enabled: false, evolutionDetection: false, constitutionalValidation: false },
          annotations: { required: false, coverage: 0.5, enforcement: 'silent' },
          templateQuality: { validation: false, encodingChecks: false },
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'low' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'weekly' },
          automatedChangelog: { enabled: false, format: 'standard' },
          predictiveEnforcement: { enabled: false, confidence: 0.9, learning: false },
        },
      };

      fs.writeFileSync(configPath, yaml.dump(disabledConfig));

      const validator = new AnnotationValidator(testProjectRoot);
      const result = await validator.validateAll();

      expect(result.valid).toBe(true);
      expect(result.coverage).toBe(1.0);
      expect(result.violations).toEqual([]);
    });

    it('should perform validation when enabled', async () => {
      const enabledConfig = {
        team: { name: 'Test Team', profile: 'strict' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true,
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: true, triggerThreshold: 'low' },
          constitutionalEnforcement: { mode: 'strict', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.9, enforcement: 'error' },
          templateQuality: { validation: true, encodingChecks: true },
        },
        optional: {
          realtimePatternDetection: { enabled: true, sensitivity: 'high' },
          autoGeneratedEvolutionStories: { enabled: true, severity: 'medium' },
          driftMonitoringDashboard: { enabled: true, updateInterval: 'hourly' },
          automatedChangelog: { enabled: true, format: 'constitutional' },
          predictiveEnforcement: { enabled: true, confidence: 0.7, learning: true },
        },
      };

      fs.writeFileSync(configPath, yaml.dump(enabledConfig));

      const validator = new AnnotationValidator(testProjectRoot);
      const result = await validator.validateAll();

      // Should perform actual validation
      expect(result.coverage).toBeGreaterThanOrEqual(0);
      expect(result.coverage).toBeLessThanOrEqual(1.0);
    });

    it('should respect different enforcement levels', async () => {
      const warningConfig = {
        team: { name: 'Test Team', profile: 'balanced' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true,
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: false, triggerThreshold: 'medium' },
          constitutionalEnforcement: { mode: 'guided', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.8, enforcement: 'warning' },
          templateQuality: { validation: true, encodingChecks: true },
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'medium' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'daily' },
          automatedChangelog: { enabled: false, format: 'constitutional' },
          predictiveEnforcement: { enabled: false, confidence: 0.8, learning: true },
        },
      };

      fs.writeFileSync(configPath, yaml.dump(warningConfig));

      const validator = new AnnotationValidator(testProjectRoot);
      const result = await validator.validateAll();

      // Should perform validation but not fail on warnings
      expect(result.coverage).toBeGreaterThanOrEqual(0);
      expect(result.coverage).toBeLessThanOrEqual(1.0);
    });
  });

  describe('Cross-Tool Integration', () => {
    it('should work together with different configuration profiles', async () => {
      const balancedConfig = {
        team: { name: 'Test Team', profile: 'balanced' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true,
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: false, triggerThreshold: 'medium' },
          constitutionalEnforcement: { mode: 'guided', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.8, enforcement: 'warning' },
          templateQuality: { validation: true, encodingChecks: true },
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'medium' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'daily' },
          automatedChangelog: { enabled: false, format: 'constitutional' },
          predictiveEnforcement: { enabled: false, confidence: 0.8, learning: true },
        },
      };

      fs.writeFileSync(configPath, yaml.dump(balancedConfig));

      // Test all tools together
      const hook = new PreCommitHook(testProjectRoot);
      const templateValidator = new TemplateQualityValidator(testProjectRoot);
      const annotationValidator = new AnnotationValidator(testProjectRoot);

      const [hookResult, templateResult, annotationResult] = await Promise.all([
        hook.run(),
        templateValidator.validateAll(),
        annotationValidator.validateAll(),
      ]);

      // All tools should respect the balanced configuration
      expect(hookResult.allowed).toBe(true);
      expect(templateResult.overall).toBeGreaterThanOrEqual(0);
      expect(annotationResult.coverage).toBeGreaterThanOrEqual(0);
    });
  });
});
