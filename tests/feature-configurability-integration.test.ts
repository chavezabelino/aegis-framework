/**
 * @aegisFrameworkVersion 2.3.0
 * @intent Integration tests for feature configurability system
 * @context Validate that all framework tools respect team configuration settings
 * @mode: strict
 */

import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import fs from 'fs';
import path from 'path';
import yaml from 'js-yaml';
import { TeamConfigLoader } from '../tools/team-config-loader.js';
import { EvolutionStoryDetector } from '../tools/detect-evolution-stories.js';
import { IntentEnforcementEngine } from '../tools/intent-enforcement-engine.js';

describe('Feature Configurability Integration', () => {
  let testProjectRoot: string;
  let configPath: string;
  let configLoader: TeamConfigLoader;

  beforeEach(() => {
    // Create temporary test directory
    testProjectRoot = fs.mkdtempSync(path.join(process.cwd(), 'test-config-'));
    configPath = path.join(testProjectRoot, '.framework', 'team-config.yaml');
    
    // Ensure .framework directory exists
    fs.mkdirSync(path.dirname(configPath), { recursive: true });
    
    configLoader = TeamConfigLoader.getInstance(testProjectRoot);
  });

  afterEach(() => {
    // Clean up test directory
    if (fs.existsSync(testProjectRoot)) {
      fs.rmSync(testProjectRoot, { recursive: true, force: true });
    }
  });

  describe('Team Configuration Loading', () => {
    it('should load balanced profile configuration', () => {
      const balancedConfig = {
        team: {
          name: 'Test Team',
          profile: 'balanced'
        },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: {
            enabled: true,
            autoGenerate: false,
            triggerThreshold: 'medium'
          },
          constitutionalEnforcement: {
            mode: 'guided',
            blocking: true,
            autoCorrection: true
          },
          precommitHooks: {
            enabled: true,
            evolutionDetection: true,
            constitutionalValidation: true
          },
          annotations: {
            required: true,
            coverage: 0.8,
            enforcement: 'warning'
          },
          templateQuality: {
            validation: true,
            encodingChecks: true
          }
        },
        optional: {
          realtimePatternDetection: {
            enabled: false,
            sensitivity: 'medium'
          },
          autoGeneratedEvolutionStories: {
            enabled: false,
            severity: 'critical'
          },
          driftMonitoringDashboard: {
            enabled: false,
            updateInterval: 'daily'
          },
          automatedChangelog: {
            enabled: false,
            format: 'constitutional'
          },
          predictiveEnforcement: {
            enabled: false,
            confidence: 0.8,
            learning: true
          }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(balancedConfig));
      
      const config = configLoader.loadConfig();
      expect(config).toBeDefined();
      expect(config?.team.profile).toBe('balanced');
      expect(config?.required.evolutionStoryDetection.enabled).toBe(true);
      expect(config?.required.constitutionalEnforcement.mode).toBe('guided');
    });

    it('should load minimal profile with overrides', () => {
      const minimalConfig = {
        team: {
          name: 'Minimal Team',
          profile: 'minimal'
        },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: {
            enabled: false,
            autoGenerate: false,
            triggerThreshold: 'high'
          },
          constitutionalEnforcement: {
            mode: 'advisory',
            blocking: false,
            autoCorrection: false
          },
          precommitHooks: {
            enabled: false,
            evolutionDetection: false,
            constitutionalValidation: false
          },
          annotations: {
            required: false,
            coverage: 0.5,
            enforcement: 'silent'
          },
          templateQuality: {
            validation: false,
            encodingChecks: false
          }
        },
        optional: {
          realtimePatternDetection: {
            enabled: false,
            sensitivity: 'low'
          },
          autoGeneratedEvolutionStories: {
            enabled: false,
            severity: 'critical'
          },
          driftMonitoringDashboard: {
            enabled: false,
            updateInterval: 'weekly'
          },
          automatedChangelog: {
            enabled: false,
            format: 'standard'
          },
          predictiveEnforcement: {
            enabled: false,
            confidence: 0.9,
            learning: false
          }
        },
        overrides: {
          constitutionalAcknowledgment: '2025-01-01',
          reason: 'Test team workflow optimization',
          approvedBy: 'test@example.com',
          overrideExpiry: '2025-05-01'
        }
      };

      fs.writeFileSync(configPath, yaml.dump(minimalConfig));
      
      const config = configLoader.loadConfig();
      expect(config).toBeDefined();
      expect(config?.team.profile).toBe('minimal');
      expect(config?.required.evolutionStoryDetection.enabled).toBe(false);
      expect(config?.required.constitutionalEnforcement.mode).toBe('advisory');
      expect(config?.overrides).toBeDefined();
    });

    it('should return null when no configuration exists', () => {
      const config = configLoader.loadConfig();
      expect(config).toBeNull();
    });
  });

  describe('Feature Flag Validation', () => {
    beforeEach(() => {
      const balancedConfig = {
        team: { name: 'Test Team', profile: 'balanced' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: false, triggerThreshold: 'medium' },
          constitutionalEnforcement: { mode: 'guided', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.8, enforcement: 'warning' },
          templateQuality: { validation: true, encodingChecks: true }
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'medium' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'daily' },
          automatedChangelog: { enabled: false, format: 'constitutional' },
          predictiveEnforcement: { enabled: false, confidence: 0.8, learning: true }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(balancedConfig));
    });

    it('should correctly identify required features as enabled', () => {
      expect(configLoader.isRequiredFeatureEnabled('evolutionStoryDetection')).toBe(true);
      expect(configLoader.isRequiredFeatureEnabled('constitutionalEnforcement')).toBe(true);
      expect(configLoader.isRequiredFeatureEnabled('precommitHooks')).toBe(true);
      expect(configLoader.isRequiredFeatureEnabled('annotations')).toBe(true);
      expect(configLoader.isRequiredFeatureEnabled('templateQuality')).toBe(true);
    });

    it('should correctly identify optional features as disabled', () => {
      expect(configLoader.isOptionalFeatureEnabled('realtimePatternDetection')).toBe(false);
      expect(configLoader.isOptionalFeatureEnabled('autoGeneratedEvolutionStories')).toBe(false);
      expect(configLoader.isOptionalFeatureEnabled('driftMonitoringDashboard')).toBe(false);
      expect(configLoader.isOptionalFeatureEnabled('automatedChangelog')).toBe(false);
      expect(configLoader.isOptionalFeatureEnabled('predictiveEnforcement')).toBe(false);
    });

    it('should return correct constitutional mode', () => {
      expect(configLoader.getConstitutionalMode()).toBe('guided');
    });

    it('should return correct annotation enforcement', () => {
      expect(configLoader.getAnnotationEnforcement()).toBe('warning');
    });
  });

  describe('Evolution Story Detection Integration', () => {
    beforeEach(() => {
      // Create docs/evolution directory
      const evolutionDir = path.join(testProjectRoot, 'docs', 'evolution');
      fs.mkdirSync(evolutionDir, { recursive: true });
      
      // Create a mock git repository to avoid detecting real commits
      const gitDir = path.join(testProjectRoot, '.git');
      fs.mkdirSync(gitDir, { recursive: true });
      fs.writeFileSync(path.join(gitDir, 'HEAD'), 'ref: refs/heads/main');
    });

    it('should respect disabled evolution story detection', async () => {
      const disabledConfig = {
        team: { name: 'Test Team', profile: 'minimal' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: false, autoGenerate: false, triggerThreshold: 'high' },
          constitutionalEnforcement: { mode: 'advisory', blocking: false, autoCorrection: false },
          precommitHooks: { enabled: false, evolutionDetection: false, constitutionalValidation: false },
          annotations: { required: false, coverage: 0.5, enforcement: 'silent' },
          templateQuality: { validation: false, encodingChecks: false }
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'low' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'weekly' },
          automatedChangelog: { enabled: false, format: 'standard' },
          predictiveEnforcement: { enabled: false, confidence: 0.9, learning: false }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(disabledConfig));

      const detector = new EvolutionStoryDetector(testProjectRoot);
      const triggers = await detector.detectTriggers();
      
      // Should return empty array when disabled
      expect(triggers).toEqual([]);
    });

    it('should respect disabled auto-generation', async () => {
      const noAutoConfig = {
        team: { name: 'Test Team', profile: 'balanced' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: false, triggerThreshold: 'medium' },
          constitutionalEnforcement: { mode: 'guided', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.8, enforcement: 'warning' },
          templateQuality: { validation: true, encodingChecks: true }
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'medium' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'daily' },
          automatedChangelog: { enabled: false, format: 'constitutional' },
          predictiveEnforcement: { enabled: false, confidence: 0.8, learning: true }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(noAutoConfig));

      const detector = new EvolutionStoryDetector(testProjectRoot);
      const stories = await detector.autoGenerateStories();
      
      // Should return empty array when auto-generation is disabled
      expect(stories).toEqual([]);
    });
  });

  describe('Intent Enforcement Integration', () => {
    it('should respect disabled constitutional enforcement', () => {
      const disabledConfig = {
        team: { name: 'Test Team', profile: 'minimal' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: false, autoGenerate: false, triggerThreshold: 'high' },
          constitutionalEnforcement: { mode: 'advisory', blocking: false, autoCorrection: false },
          precommitHooks: { enabled: false, evolutionDetection: false, constitutionalValidation: false },
          annotations: { required: false, coverage: 0.5, enforcement: 'silent' },
          templateQuality: { validation: false, encodingChecks: false }
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'low' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'weekly' },
          automatedChangelog: { enabled: false, format: 'standard' },
          predictiveEnforcement: { enabled: false, confidence: 0.9, learning: false }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(disabledConfig));

      const engine = new IntentEnforcementEngine(testProjectRoot);
      
      // Set execution intent to avoid constitutional violation
      engine.setExecutionIntent({
        primaryGoal: 'Test feature configurability',
        mode: 'strict',
        expectedActions: ['echo'],
        forbiddenActions: [],
        safetyConstraints: []
      });
      
      const result = engine.enforceIntent('echo "test"', 'Test command');
      
      // Should allow execution when disabled
      expect(result.allowed).toBe(true);
      expect(result.violations).toEqual([]);
    });

    it('should respect different enforcement modes', () => {
      const strictConfig = {
        team: { name: 'Test Team', profile: 'strict' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: true, triggerThreshold: 'low' },
          constitutionalEnforcement: { mode: 'strict', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.9, enforcement: 'error' },
          templateQuality: { validation: true, encodingChecks: true }
        },
        optional: {
          realtimePatternDetection: { enabled: true, sensitivity: 'high' },
          autoGeneratedEvolutionStories: { enabled: true, severity: 'medium' },
          driftMonitoringDashboard: { enabled: true, updateInterval: 'hourly' },
          automatedChangelog: { enabled: true, format: 'constitutional' },
          predictiveEnforcement: { enabled: true, confidence: 0.7, learning: true }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(strictConfig));

      const engine = new IntentEnforcementEngine(testProjectRoot);
      
      // Should block execution without intent in strict mode
      const result = engine.enforceIntent('echo "test"', 'Test command');
      expect(result.allowed).toBe(false);
      expect(result.violations.length).toBeGreaterThan(0);
    });
  });

  describe('Configuration Caching', () => {
    it('should cache configuration for performance', () => {
      const config = {
        team: { name: 'Test Team', profile: 'balanced' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: false, triggerThreshold: 'medium' },
          constitutionalEnforcement: { mode: 'guided', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.8, enforcement: 'warning' },
          templateQuality: { validation: true, encodingChecks: true }
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'medium' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'daily' },
          automatedChangelog: { enabled: false, format: 'constitutional' },
          predictiveEnforcement: { enabled: false, confidence: 0.8, learning: true }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(config));
      
      // First load
      const config1 = configLoader.loadConfig();
      expect(config1).toBeDefined();
      
      // Second load should use cache
      const config2 = configLoader.loadConfig();
      expect(config2).toBeDefined();
      expect(config2).toBe(config1); // Same object reference
    });

    it('should reload when cache expires', () => {
      const config = {
        team: { name: 'Test Team', profile: 'balanced' },
        core: {
          blueprintValidation: true,
          agentDriftPrevention: true,
          intentEnforcement: true,
          versionConsistency: true
        },
        required: {
          evolutionStoryDetection: { enabled: true, autoGenerate: false, triggerThreshold: 'medium' },
          constitutionalEnforcement: { mode: 'guided', blocking: true, autoCorrection: true },
          precommitHooks: { enabled: true, evolutionDetection: true, constitutionalValidation: true },
          annotations: { required: true, coverage: 0.8, enforcement: 'warning' },
          templateQuality: { validation: true, encodingChecks: true }
        },
        optional: {
          realtimePatternDetection: { enabled: false, sensitivity: 'medium' },
          autoGeneratedEvolutionStories: { enabled: false, severity: 'critical' },
          driftMonitoringDashboard: { enabled: false, updateInterval: 'daily' },
          automatedChangelog: { enabled: false, format: 'constitutional' },
          predictiveEnforcement: { enabled: false, confidence: 0.8, learning: true }
        }
      };

      fs.writeFileSync(configPath, yaml.dump(config));
      
      // First load
      const config1 = configLoader.loadConfig();
      
      // Force reload
      const config2 = configLoader.reloadConfig();
      expect(config2).toBeDefined();
      expect(config2).not.toBe(config1); // Different object reference
    });
  });
});
